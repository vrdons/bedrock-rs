//! Connection state types used by the RakNet session layer.
//!
//! These enums model high-level connection lifecycle and reasons for
//! transitions, some of which are serialised on the wire.

use bytes::{Buf, BufMut};

use crate::protocol::packet::{DecodeError, EncodeError, RaknetEncodable};

/// Reason codes sent with certain disconnect/control packets.
#[derive(Debug, Clone, Copy)]
#[repr(u8)]
pub enum DisconnectReason {
    ClosedByRemotePeer,
    ShuttingDown,
    Disconnected,
    TimedOut,
    ConnectionRequestFailed,
    AlreadyConnected,
    NoFreeIncomingConnections,
    IncompatibleProtocolVersion,
    IPRecentlyConnected,
    BadPacket,
    QueueTooLong,
}

impl RaknetEncodable for DisconnectReason {
    fn encode_raknet(&self, dst: &mut impl BufMut) -> Result<(), EncodeError> {
        (*self as u8).encode_raknet(dst)
    }

    fn decode_raknet(src: &mut impl Buf) -> Result<Self, DecodeError> {
        let v = u8::decode_raknet(src)?;
        let e = match v {
            0 => DisconnectReason::ClosedByRemotePeer,
            1 => DisconnectReason::ShuttingDown,
            2 => DisconnectReason::Disconnected,
            3 => DisconnectReason::TimedOut,
            4 => DisconnectReason::ConnectionRequestFailed,
            5 => DisconnectReason::AlreadyConnected,
            6 => DisconnectReason::NoFreeIncomingConnections,
            7 => DisconnectReason::IncompatibleProtocolVersion,
            8 => DisconnectReason::IPRecentlyConnected,
            9 => DisconnectReason::BadPacket,
            10 => DisconnectReason::QueueTooLong,
            _ => return Err(DecodeError::UnknownDisconnectReason(v)),
        };
        Ok(e)
    }
}

/// High-level events generated by the protocol layer.
#[repr(u8)]
pub enum Event {
    /// A new incoming connection has been fully established.
    NewIncomingConnection,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum RakPriority {
    Immediate = 0,
    High = 1,
    Normal = 2,
    Low = 3,
}

impl RakPriority {
    pub fn as_index(self) -> usize {
        self as usize
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use bytes::BytesMut;

    #[test]
    fn disconnect_reason_roundtrip() {
        for reason in [
            DisconnectReason::ClosedByRemotePeer,
            DisconnectReason::TimedOut,
            DisconnectReason::QueueTooLong,
        ] {
            let mut buf = BytesMut::new();
            reason.encode_raknet(&mut buf).unwrap();
            let mut slice = buf.freeze();
            let decoded = DisconnectReason::decode_raknet(&mut slice).unwrap();
            // encode as u8 again and compare discriminants
            let mut orig_buf = BytesMut::new();
            reason.encode_raknet(&mut orig_buf).unwrap();
            let mut orig_slice = orig_buf.freeze();
            let orig_u8 = u8::decode_raknet(&mut orig_slice).unwrap();
            let mut dec_buf = BytesMut::new();
            decoded.encode_raknet(&mut dec_buf).unwrap();
            let mut dec_slice = dec_buf.freeze();
            let dec_u8 = u8::decode_raknet(&mut dec_slice).unwrap();
            assert_eq!(orig_u8, dec_u8);
        }
    }
}
